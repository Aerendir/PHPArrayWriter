<?php

/**
 *    @author      Aerendir <hello@aerendir.me>
 *    @copyright   Copyright (C) 2014 SerendipityHQ. All rights reserved.
 */
namespace SHQ\Component\ArrayWriter;

use Symfony\Component\PropertyAccess\Exception\AccessException;
use Symfony\Component\PropertyAccess\Exception\NoSuchIndexException;
use Symfony\Component\PropertyAccess\PropertyAccess;
use Symfony\Component\PropertyAccess\PropertyPathBuilder;

/**
 * Manages some writing operations on the passed array.
 *
 * It uses a *UNIX like syntax:
 * - cp: copy a value to another path (and left intact the value in the original location)
 * - mv: moves a value to another path
 * - rm: removes a value from the given path
 *
 * @since 2
 */
class ArrayWriter
{
    /** @var \Symfony\Component\PropertyAccess\PropertyAccessor $pa The PropertyAccessor used to manipulate the array */
    private $pa;

    /**
     * Builds an instance of PropertyAccessor.
     */
    public function __construct()
    {
        $accessorBuilder = PropertyAccess::createPropertyAccessorBuilder();
        $accessorBuilder->enableExceptionOnInvalidIndex();
        $this->pa = $accessorBuilder->getPropertyAccessor();
    }

    /**
     * Get the value of the given path from the array graph.
     *
     * @param array $array
     * @param string $path
     * @return array
     */
    public function getValue(array $array, $path)
    {
        // If the $path value is empty, return the entire array graph
        if ('' === $path) {
            return $array;
        }

        // If $path doesn't exist returns null. It is not possible to distinghuish between a path that exists and has a
        // null value and a path that doesn't exist at all.
        return $this->pa->getValue($array, $path);
    }
    
    /**
     * Checks if a given path is a node or not.
     *
     * @param array $array
     * @param string $path
     * @return bool
     */
    public function isNode(array $array, $path)
    {
        return is_array($this->getValue($array, $path));
    }

    /**
     * Checks if a path exists in the given array.
     *
     * @param array $array
     * @param $path
     * @return bool
     */
    public function isReadable(array $array, $path)
    {
        try {
            return $this->pa->isReadable($array, $path);
        } catch (\Exception $e) {
            return false;
        }
    }
    
    /**
     * @param $path
     * @return bool
     */
    public function isRoot($path)
    {
        return '[]' === $path || '' === $path;
    }
    
    /**
     * Returns true if the $path is null, false instead.
     * 
     * @param array $array
     * @param $path
     * @return bool
     */
    public function isWritable(array $array, $path)
    {
        if ($this->isRoot($path))
            return false;
        
        try {
            $this->pa->getValue($array, $path);
        } catch (NoSuchIndexException $e) {
            // If the exception is thrown, the value can be written at given $path as it hasn't already a value
            return true;
        }
        
        return false;
    }

    /**
     * Adds a value to a node.
     *
     * The method can recognize if the current value at $toPath is a string: if it is, the method first transforms the
     * current value into an array and then adds the new value to this new array, so preserving the already present
     * value.
     * 
     * Passing $propertyForNewValue and $propertyForOldValue it is possible to set the property names of the already
     * present value and of the newly created value.
     * 
     * If the key doesn't exist, the method simply adds it.
     * 
     * @param array  $array Passed by reference
     * @param string $toPath The location where to add the value taken $fromPath
     * @param mixed  $value The value to add
     * @param string $propertyForNewValue The name to give to the new property
     * @param string $propertyForOldValue The old value is now assigned to a property: this is its property name
     */
    public function add(array &$array, $toPath, $value, $propertyForNewValue = '', $propertyForOldValue = '')
    {
        // Get the value at destination path (to preserve it if isn't an array)
        $currentValue = $this->getValue($array, $toPath);

        // If the current value isn't yet an array...
        if (false === is_array($currentValue)) {
            // ... Transform the current value into an array
            $currentValue = '' === $propertyForOldValue
                // Use the autogenerated keys
                ? [$currentValue]
                // Use the passed key name
                : [$propertyForOldValue => $currentValue] ;
        }

        // Add the new value to the array
        if ('' === $propertyForNewValue) {
            // If no property name is set for the new value, simply add it
            $currentValue[] = $value;
        } else {
            // Remove "[" and "]"
            $propertyForNewValue = rtrim(ltrim($propertyForNewValue, '['), ']');

            // ! ! ! THIS MAY OVERWRITE A YET EXISTENT VALUE ! ! !
            $currentValue[$propertyForNewValue] = $value;
        }

        $this->edit($array, $toPath, $currentValue);
    }

    /**
     * Copy a value from $from path to $to path.
     * 
     * If the $to path has already a value, it will be overwritten.
     *
     * @param array $array
     * @param $from
     * @param $to
     * 
     * @throws AccessException if the $from path is not readable
     */
    public function cp(array &$array, $from, $to)
    {
        // If $from is not readable
        if (false === $this->pa->isReadable($array, $from)) {
            throw new AccessException(sprintf('The $from path "%s" isn\'t readable.', $from));
        }

        // Get the value to move
        $value = $this->pa->getValue($array, $from);

        // Do the copy
        $this->pa->setValue($array, $to, $value);
    }

    /**
     * Copy a value from $from path to $to path.
     * 
     * If the $to path already has a value, an AccessException is thrown.
     *
     * @param array $array
     * @param $from
     * @param $to
     * 
     * @throws AccessException If the $to path already has a value
     */
    public function cpSafe(array &$array, $from, $to)
    {
        // If $from is not readable
        if (false === $this->isWritable($array, $to)) {
            throw new AccessException(sprintf('The $to path "%s" isn\'t writable as it already has a value.', $to));
        }
        
        $this->cp($array, $from, $to);
    }
    
    /**
     * Edits the value at the given path.
     * @param array $array
     * @param string $path
     * @param $value
     * 
     * @throws AccessException If the path to edit is not readable
     */
    public function edit(array &$array, $path, $value)
    {
        // If $path is not writable
        if (false === $this->isRoot($path) && false === $this->pa->isReadable($array, $path)) {
            throw new AccessException(sprintf('The path "%s" you are trying to edit isn\'t readable and so cannot be edited.', $path));
        }
        
        if ($this->isRoot($path))
            $array = $value;
        else
            $this->pa->setValue($array, $path, $value);
    }

    /**
     * Moves an element from $from path to $to path.
     * 
     * If $to path already has a value, it will be overwritten.
     *
     * @param array $array
     * @param string $from
     * @param string $to
     * 
     * @throws AccessException if $from path is not readable.
     */
    public function mv(array &$array, $from, $to)
    {
        // Do the moving
        $this->cp($array, $from, $to);
        
        // Remove the original value
        $this->rm($array, $from);
    }

    /**
     * Moves an element from $from path to $to path.
     * 
     * If $to path already has a value, an AccessException will be thrown.
     *
     * @param array $array
     * @param string $from
     * @param string $to
     * 
     * @throws AccessException if $from path is not readable
     * @throws AccessException if the $to path already has a value
     */
    public function mvSafe(array &$array, $from, $to)
    {
        // Do the moving
        $this->cpSafe($array, $from, $to);

        // Remove the original value
        $this->rm($array, $from);
    }
    
    /**
     * Removes an element from the array.
     *
     * @link http://stackoverflow.com/a/16698855/1399706
     *
     * @param array $array
     * @param string $path
     */
    public function rm(array &$array, $path)
    {
        $path = new PropertyPathBuilder($path);

        $nodes = $path->getPropertyPath()->getElements();
        $parentLevel = null;
        $currentLevel = &$array;
        foreach ($nodes as &$node) {
            $parentLevel = &$currentLevel;
            $currentLevel = &$currentLevel[$node];
        }

        if ($parentLevel !== null) {
            unset($parentLevel[$node]);
        }
    }

    /**
     * Adds a parent key to the current array.
     *
     * For example, given this array:
     *
     *     $array = [
     *         0 => 'element 0', 1 => 'element 1', 2 => 'element 2', ...
     *     ];
     *
     * calling ArrayWriter('', 'root') will rearrange the array in this way:
     *
     *     $array = [
     *         'root' => [
     *             0 => 'element 0', 1 => 'element 1', 2 => 'element 2', ...
     *         ]
     *     ];
     *
     * @param array $array
     * @param string $path
     * @param string $wrapperName
     * 
     * @return array
     */
    public function wrap(array &$array, $path, $wrapperName)
    {
        // Get the value to move: if path is empty, get the full array graph
        $value = (empty($path) || '[]' === $path) ? $array : $this->pa->getValue($array, $path);

        // Remove eventual [ or ] from the $wrapperName
        $wrapperName = $this->removePathDelimiters($wrapperName);

        $value = [$wrapperName => $value];

        // Set the new value: if path is empty, edit the full Array Graph, edit only the given path instead
        if (empty($path)) {
            $array = $value;
        } else {
            $this->edit($array, $path, $value);
        }
    }
    
    /**
     * Removes "[" and "]" from path.
     * 
     * @param $path
     * @return string
     */
    private function removePathDelimiters($path)
    {
        return str_replace(['[', ']'], '', $path);
    }
}
